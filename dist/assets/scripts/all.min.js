(function() {
  var GameController, app;

  app = angular.module('battlecruisers', ['ngRoute', 'battlecruisers-players', 'battlecruisers-cards']);

  app.config(function($routeProvider, $locationProvider) {
    $locationProvider.html5Mode(true);
    return $routeProvider.when('/', {
      templateUrl: 'index.html',
      controller: 'GameController',
      controllerAs: 'game'
    }).when('/partials/:name', {
      templateUrl: 'partials/:name'
    }).otherwise({
      redirectTo: '/'
    });
  });

  GameController = function($http, cardService, playerService) {
    var game;
    game = this;
    game.newGame = function(players_array) {
      var computer_players, human_players, i, id, j, player, ref, ref1, ref2, ref3;
      computer_players = players_array[0];
      human_players = players_array[1];
      game.turn_number = 0;
      game.over = false;
      for (id = i = 1, ref = human_players; 1 <= ref ? i <= ref : i >= ref; id = 1 <= ref ? ++i : --i) {
        player = playerService.createNewPlayer(id, 'human');
        player.cards = cardService.getHand();
        playerService.updatePlayer(id, player);
        console.log(player);
      }
      for (id = j = ref1 = 1 + human_players, ref2 = computer_players + human_players; ref1 <= ref2 ? j <= ref2 : j >= ref2; id = ref1 <= ref2 ? ++j : --j) {
        player = playerService.createNewPlayer(id, 'ai');
        player.cards = cardService.getHand();
        playerService.updatePlayer(id, player);
      }
      ref3 = playerService.players;
      for (id in ref3) {
        player = ref3[id];
        playerService.addTokensToPlayerPile(id, 1);
        playerService.moveCardToPile(id, "hand", "recovery_zone");
        playerService.moveCardToPile(id, "hand", "discard_pile");
      }
      game.buttons.new_game.active = false;
      return game.buttons.start_game.active = true;
    };
    game.reset = function() {
      var button, id, ref, ref1, results;
      console.warn('RESETTING GAME!');
      game.turn_number = 0;
      playerService.reset();
      cardService.resetCardsInPlay();
      game.cardsInPlay = cardService.cardsInPlay;
      game.cards = {};
      game.cards.actions = cardService.actions;
      cardService.getDeck().success(function(data) {
        game.cards.deck = data;
        return cardService.updateDeck(data);
      });
      ref = game.buttons;
      results = [];
      for (id in ref) {
        button = ref[id];
        if ((ref1 = button.id) === 'new_game') {
          results.push(button.active = true);
        } else {
          results.push(button.active = false);
        }
      }
      return results;
    };
    game.runGame = function() {
      game.buttons.start_game.active = false;
      game.turn();
      return game.buttons.next_turn.active = true;
    };
    game.turn = function() {
      var card, cardPlayed, card_number, count, i, id, j, k, len, len1, len2, player, player_id, random_card, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, total_cards;
      if (game.over) {
        return game.buttons.next_turn.disabled = true;
      } else {
        game.buttons.next_turn.disabled = true;
        game.turn_number += 1;
        if (game.turn_number > 1) {
          ref = playerService.players;
          for (id in ref) {
            player = ref[id];
            ref1 = player.cards.recovery_zone;
            for (i = 0, len = ref1.length; i < len; i++) {
              card = ref1[i];
              playerService.moveCardToPile(id, "recovery_zone", "hand", 0);
            }
            ref2 = player.cards.in_play;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              card = ref2[j];
              playerService.moveCardToPile(id, "in_play", "recovery_zone", 0);
            }
          }
        }
        cardService.resetCardsInPlay();
        ref3 = playerService.players;
        for (id in ref3) {
          player = ref3[id];
          if (player.status !== "ELIMINATED") {
            if (player.type === "ai") {
              random_card = player.cards.random_card(["hand"]);
              cardPlayed = playerService.moveCardToPile(id, "hand", "in_play", random_card.index);
              cardService.cardsInPlay.cardsPlayed[id] = cardPlayed;
              cardService.cardsInPlay.cardNumberCounts[cardPlayed.id] += 1;
              cardService.updateCardsInPlay(cardService.cardsInPlay);
            } else {
              console.warn("Removing Player " + player.id + " from game for being human");
            }
          } else {
            console.warn("Removing Player " + player.id + " from game for being eliminated");
          }
        }
        cardService.cardsInPlay.show = true;
        ref4 = cardService.cardsInPlay.cardNumberCounts;
        for (card_number in ref4) {
          count = ref4[card_number];
          if (count > 0) {
            if (count === 1) {
              ref5 = cardService.cardsInPlay.cardsPlayed;
              for (player_id in ref5) {
                card = ref5[player_id];
                if (card_number === card.id.toString()) {
                  console.debug("Player " + player_id + " played card #" + card.id);
                  game.cards.actions[card_number].main(player_id);
                }
              }
            } else {
              ref6 = cardService.cardsInPlay.cardsPlayed;
              for (player_id in ref6) {
                card = ref6[player_id];
                if (card_number === card.id.toString()) {
                  console.debug("Player " + player_id + " played card #" + card.id);
                  game.cards.actions[card_number].conflict(player_id);
                }
              }
            }
          }
        }
        ref7 = playerService.players;
        for (id in ref7) {
          player = ref7[id];
          total_cards = player.cards.hand.length + player.cards.recovery_zone.length;
          if (total_cards === 0) {
            player.status = "ELIMINATED";
          } else if (total_cards === 1) {
            player.status = "RED ALERT";
          } else {
            player.status = "NORMAL";
          }
        }
        ref8 = playerService.players;
        for (id in ref8) {
          player = ref8[id];
          if (player.tokens >= 15) {
            player.winner = true;
            game.over = true;
          }
          if (playerService.players.length === 1) {
            player.winner = true;
            game.over = true;
          }
        }
        if (!game.over) {
          game.buttons.next_turn.disabled = false;
          ref9 = playerService.players;
          for (k = 0, len2 = ref9.length; k < len2; k++) {
            player = ref9[k];
            playerService.addSafeTurnsToPlayer(player_id, -1);
          }
        } else {
          game.buttons.reset_game.active = true;
        }
        return console.log(cardService.cardsInPlay);
      }
    };
    game.buttons = {};
    $http.get('/static/data/buttons.json').success(function(data) {
      return game.buttons = data;
    });
    game.button_actions = {
      "new_game": game.newGame,
      "start_game": game.runGame,
      "next_turn": game.turn,
      "reset_game": game.reset
    };
    game.reset();
    return game;
  };

  app.controller('GameController', ['$http', 'cardService', 'playerService', GameController]);

  app.directive('playArea', [
    'cardService', function(cardService) {
      return {
        restrict: 'E',
        templateUrl: 'partials/play-area',
        link: function(scope, el, attrs) {
          return scope.cardService = cardService;
        }
      };
    }
  ]);

  app.directive('gameHeader', function() {
    return {
      restrict: 'E',
      templateUrl: 'partials/game-header',
      scope: true
    };
  });

  app.directive('gameControlButtons', function() {
    return {
      restrict: 'E',
      templateUrl: 'partials/game-control-buttons',
      scope: true
    };
  });

  return app;

}).call(this);

(function() {
  var app,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  app = angular.module('battlecruisers-cards', []);

  app.service('cardService', [
    '$http', 'playerService', function($http, playerService) {
      var cardService;
      cardService = {};
      cardService.deck = {};
      cardService.getDeck = function() {
        return $http.get('/static/data/cards.json');
      };
      cardService.actions = {
        "3": {
          "main": function(player_id) {
            console.debug("Player " + player_id + " is safe from main effects for this turn and next");
            return playerService.addSafeTurnsToPlayer(player_id, 2);
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " in conflict but nothing happens");
            return null;
          }
        },
        "11": {
          "main": function(player_id) {
            console.debug("Player " + player_id + " earns 4 tokens and discards a card");
            playerService.addTokensToPlayerPile(player_id, 4);
            return playerService.moveCardToPile(player_id, ["hand", "recovery_zone"], "discard_pile");
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict and discards a card");
            return playerService.moveCardToPile(player_id, ["hand", "recovery_zone"], "discard_pile");
          }
        },
        "13": {
          "main": function(player_id) {
            console.debug("Player " + player_id + " earns 3 tokens");
            return playerService.addTokensToPlayerPile(player_id, 3);
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict, so gains 3 tokens but loses 1 for each conflict");
            playerService.addTokensToPlayerPile(player_id, 3);
            return playerService.addTokensToPlayerPile(player_id, -cardService.cardsInPlay.cardNumberCounts["13"]);
          }
        },
        "22": {
          "main": function(player_id) {
            var players, results, victim, victim_id;
            console.debug("Player " + player_id + " takes a token from all players, if they are not in the lead");
            players = playerService.players;
            if (indexOf.call(playerService.whoHasMostTokens(), player_id) < 0) {
              results = [];
              for (victim_id in players) {
                victim = players[victim_id];
                if (victim_id !== player_id && victim["safe_turns"] <= 0) {
                  if (victim["tokens"] > 0) {
                    playerService.addTokensToPlayerPile(victim_id, -1);
                    results.push(playerService.addTokensToPlayerPile(player_id, 1));
                  } else {
                    results.push(void 0);
                  }
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict but nothing happens");
            return null;
          }
        },
        "31": {
          "main": function(player_id) {
            var players, results, victim, victim_id;
            console.debug("Player " + player_id + " commands every opponent to discard a card");
            players = playerService.players;
            results = [];
            for (victim_id in players) {
              victim = players[victim_id];
              if (victim_id === !player_id && victim["safe_turns"] <= 0) {
                results.push(playerService.moveCardToPile(victim_id, "discard_pile", "hand"));
              } else {
                results.push(void 0);
              }
            }
            return results;
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict and discards a card");
            return playerService.moveCardToPile(player_id, "discard_pile", "hand");
          }
        },
        "43": {
          "main": function(player_id) {
            var players;
            playerService.addTokensToPlayerPile(player_id, 1);
            console.debug("Player " + player_id + " takes 3 cards from their discard pile if they only have one card remaining");
            players = playerService.players;
            if (players[player_id].cards.hand.length === 1) {
              return playerService.moveCardToPile(player_id, "discard_pile", "hand");
            }
          },
          "conflict": function(player_id) {
            var i, index, players, ref, results;
            console.debug("Player " + player_id + " is in conflict and must discard this card (#43)");
            players = playerService.players;
            results = [];
            for (index = i = ref = players[player_id].cards.in_play.length - 1; ref <= 0 ? i < 0 : i > 0; index = ref <= 0 ? ++i : --i) {
              if (players[player_id].cards.in_play[index].id === "43") {
                playerService.moveCardToPile(player_id, "in_play", "discard_pile", index);
                break;
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        }
      };
      cardService.updateDeck = function(deck) {
        cardService.deck = deck;
        return deck;
      };
      cardService.handChoice = [3, 11, 13, 22, 31, 43];
      cardService.getHand = function(card_numbers) {
        var card, card_number, hand, i, len;
        if (card_numbers == null) {
          card_numbers = cardService.handChoice;
        }
        hand = [];
        for (i = 0, len = card_numbers.length; i < len; i++) {
          card_number = card_numbers[i];
          card = cardService.deck[card_number];
          card["id"] = card_number;
          hand.push(card);
        }
        return {
          hand: hand,
          in_play: [],
          discard_pile: [],
          recovery_zone: [],
          active_cards: function(piles) {
            var card_count, j, len1, pile;
            if (piles == null) {
              piles = ["hand", "in_play", "recovery_zone"];
            }
            card_count = 0;
            for (j = 0, len1 = piles.length; j < len1; j++) {
              pile = piles[j];
              card_count += this[pile].length;
            }
            return card_count;
          },
          random_card: function(piles) {
            var j, len1, pile, pile_size, rand;
            if (piles == null) {
              piles = ["hand", "in_play", "recovery_zone"];
            }
            rand = Math.floor(Math.random() * this.active_cards(piles));
            for (j = 0, len1 = piles.length; j < len1; j++) {
              pile = piles[j];
              pile_size = this[pile].length;
              if (rand < pile_size) {
                return {
                  card: this[pile][rand],
                  pile: pile,
                  index: rand
                };
              } else {
                rand -= pile_size;
              }
            }
          }
        };
      };
      cardService.updateCardsInPlay = function(cardsInPlay) {
        return cardService.cardsInPlay = cardsInPlay;
      };
      cardService.resetCardsInPlay = function() {
        return cardService.cardsInPlay = {
          "show": false,
          "cardsPlayed": {},
          "cardNumberCounts": new function() {
            var f, i, len, ref;
            ref = cardService.handChoice;
            for (i = 0, len = ref.length; i < len; i++) {
              f = ref[i];
              this[f] = 0;
            }
            return this;
          }
        };
      };
      return cardService;
    }
  ]);

  app.directive('singleCard', function() {
    return {
      restrict: 'E',
      templateUrl: 'partials/single-card',
      scope: true
    };
  });

  return app;

}).call(this);

(function() {
  var app;

  app = angular.module('battlecruisers-players', []);

  app.directive('playerInfo', [
    'playerService', function(playerService) {
      return {
        restrict: 'E',
        templateUrl: 'partials/player-info',
        link: function(scope, el, attrs) {
          return scope.playerService = playerService;
        }
      };
    }
  ]);

  app.service('playerService', [
    function() {
      var playerService;
      playerService = {};
      playerService.players = {};
      playerService.token_pool = 34;
      playerService.createNewPlayer = function(id, type) {
        var player;
        player = {
          "id": id,
          "status": "NORMAL",
          "type": type,
          "view": "remote",
          "tokens": 0,
          "safe_turns": 0
        };
        playerService.updatePlayer(id, player);
        return player;
      };
      playerService.updatePlayer = function(id, player) {
        playerService.players[id] = player;
        return player;
      };
      playerService.reset = function() {
        playerService.players = {};
        return playerService.token_pool = 34;
      };
      playerService.whoHasMostTokens = function() {
        var highest_tokens, id, player, player_ids, ref;
        highest_tokens = 0;
        player_ids = [];
        ref = playerService.players;
        for (id in ref) {
          player = ref[id];
          if (player.tokens > highest_tokens) {
            highest_tokens = player.tokens;
            player_ids = [id];
          } else if (player.tokens === highest_tokens) {
            player_ids.push(id);
          }
        }
        return player_ids;
      };
      playerService.addSafeTurnsToPlayer = function(player_id, num) {
        var player;
        player = playerService.players[player_id];
        if (player.safe_turns + num > 0) {
          player.safe_turns += num;
        } else {
          player.safe_turns = 0;
        }
        return {
          player_id: player
        };
      };
      playerService.addTokensToPlayerPile = function(player_id, num) {
        var player;
        player = playerService.players[player_id];
        if (player.tokens + num > 0) {
          if (playerService.token_pool + num > 0) {
            player.tokens += num;
            playerService.token_pool -= num;
          } else {
            player.tokens += playerService.token_pool;
            playerService.token_pool = 0;
          }
        } else {
          playerService.token_pool -= player.tokens;
          player.tokens = 0;
        }
        return {
          player_id: playerService.players[player_id]
        };
      };
      playerService.randomCardFromHand = function(pile) {
        return Math.floor(Math.random() * pile.length);
      };
      playerService.moveCardToPile = function(player_id, from_pile, to_pile, card) {
        var player;
        if (typeof from_pile === "string") {
          from_pile = [from_pile];
        }
        if (card === void 0) {
          card = playerService.players[player_id].cards.random_card(from_pile).index;
        }
        console.debug("Player " + player_id + " moves Card #" + card + " from " + from_pile + " to " + to_pile);
        player = playerService.players[player_id];
        if (player.cards[from_pile][card] !== void 0) {
          player.cards[to_pile].push(player.cards[from_pile][card]);
        } else {
          throw new Error("That card (" + card + ") is undefined! From: " + from_pile + " To: " + to_pile + " For Player " + player_id);
        }
        return player.cards[from_pile].splice(card, 1)[0];
      };
      return playerService;
    }
  ]);

}).call(this);
