(function() {
  var GameController, app;

  app = angular.module('battlecruisers', ['ngRoute', 'battlecruisers-players', 'battlecruisers-cards']);

  app.config(function($routeProvider, $locationProvider) {
    $locationProvider.html5Mode(true);
    return $routeProvider.when('/', {
      templateUrl: 'index.html',
      controller: 'GameController',
      controllerAs: 'game'
    }).when('/partials/:name', {
      templateUrl: 'partials/:name'
    }).otherwise({
      redirectTo: '/'
    });
  });

  GameController = function($http, $timeout, cardService, playerService) {
    var game;
    game = this;
    game.phase = 0;
    game.newGame = function(players_array) {
      var computer_players, human_players, i, id, j, player, ref, ref1, ref2, ref3;
      computer_players = players_array[0];
      human_players = players_array[1];
      game.turn_number = 0;
      game.over = false;
      game.phase = 1;
      for (id = i = 1, ref = human_players; 1 <= ref ? i <= ref : i >= ref; id = 1 <= ref ? ++i : --i) {
        player = playerService.createNewPlayer(id, 'human');
        player.cards = cardService.getHand();
        playerService.updatePlayer(id, player);
        console.log(player);
      }
      for (id = j = ref1 = 1 + human_players, ref2 = computer_players + human_players; ref1 <= ref2 ? j <= ref2 : j >= ref2; id = ref1 <= ref2 ? ++j : --j) {
        player = playerService.createNewPlayer(id, 'ai');
        player.cards = cardService.getHand();
        playerService.updatePlayer(id, player);
      }
      ref3 = playerService.players;
      for (id in ref3) {
        player = ref3[id];
        playerService.addTokensToPlayerPile(id, 1);
        playerService.moveCardToPile(id, "hand", "recovery_zone");
        playerService.moveCardToPile(id, "hand", "discard_pile");
      }
      game.buttons.new_game.active = false;
      return game.buttons.start_game.active = true;
    };
    game.reset = function() {
      var button, id, ref, ref1, results;
      console.warn('RESETTING GAME!');
      game.turn_number = 0;
      game.phase = 0;
      playerService.reset();
      cardService.resetCardsInPlay();
      game.cardsInPlay = cardService.cardsInPlay;
      game.cards = {};
      game.cards.actions = cardService.actions;
      cardService.getDeck().success(function(data) {
        game.cards.deck = data;
        return cardService.updateDeck(data);
      });
      ref = game.buttons;
      results = [];
      for (id in ref) {
        button = ref[id];
        if ((ref1 = button.id) === 'new_game') {
          results.push(button.active = true);
        } else {
          results.push(button.active = false);
        }
      }
      return results;
    };
    game.runGame = function() {
      game.buttons.start_game.active = false;
      game.turn_fn();
      return game.buttons.next_turn.active = true;
    };
    game.turn = {};
    game.turn.processCardActions = function() {
      var card, card_number, count, player_id, ref, results;
      ref = cardService.cardsInPlay.cardNumberCounts;
      results = [];
      for (card_number in ref) {
        count = ref[card_number];
        if (count > 0) {
          if (count === 1) {
            results.push((function() {
              var ref1, results1;
              ref1 = cardService.cardsInPlay.cardsPlayed;
              results1 = [];
              for (player_id in ref1) {
                card = ref1[player_id];
                if (card_number === card.id.toString()) {
                  console.debug("Player " + player_id + " played card #" + card.id);
                  results1.push(game.cards.actions[card_number].main(player_id));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            })());
          } else {
            results.push((function() {
              var ref1, results1;
              ref1 = cardService.cardsInPlay.cardsPlayed;
              results1 = [];
              for (player_id in ref1) {
                card = ref1[player_id];
                if (card_number === card.id.toString()) {
                  console.debug("Player " + player_id + " played card #" + card.id);
                  results1.push(game.cards.actions[card_number].conflict(player_id));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            })());
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    game.turn.rotateCardStacks = function() {
      var card, i, id, j, len, len1, player, ref, ref1, ref2;
      if (game.turn_number > 1) {
        ref = playerService.players;
        for (id in ref) {
          player = ref[id];
          ref1 = player.cards.recovery_zone;
          for (i = 0, len = ref1.length; i < len; i++) {
            card = ref1[i];
            playerService.moveCardToPile(id, "recovery_zone", "hand", 0);
          }
          ref2 = player.cards.in_play;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            card = ref2[j];
            playerService.moveCardToPile(id, "in_play", "recovery_zone", 0);
          }
        }
      }
      return cardService.resetCardsInPlay();
    };
    game.turn.playAIHands = function() {
      var cardPlayed, player, player_id, random_card, ref, results;
      ref = playerService.players;
      results = [];
      for (player_id in ref) {
        player = ref[player_id];
        if (player.status !== "ELIMINATED" && player.type === 0) {
          if (player.difficulty === 0) {
            random_card = player.cards.random_card(["hand"]);
            cardPlayed = playerService.moveCardToPile(player_id, "hand", "in_play", random_card.index);
            cardService.cardsInPlay.cardsPlayed[player_id] = cardPlayed;
            cardService.cardsInPlay.cardNumberCounts[cardPlayed.id] += 1;
            results.push(cardService.updateCardsInPlay(cardService.cardsInPlay));
          } else {
            results.push(console.error("No or invalid AI difficulty set.", player, player.difficulty, player.difficulty === 0));
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    game.turn.checkForElimination = function() {
      var id, player, ref, results, total_cards;
      ref = playerService.players;
      results = [];
      for (id in ref) {
        player = ref[id];
        total_cards = player.cards.hand.length + player.cards.recovery_zone.length;
        if (total_cards === 0) {
          results.push(player.status = "ELIMINATED");
        } else if (total_cards === 1) {
          results.push(player.status = "RED ALERT");
        } else {
          results.push(player.status = "NORMAL");
        }
      }
      return results;
    };
    game.turn.checkForEndOfGame = function() {
      var id, player, ref, results;
      ref = playerService.players;
      results = [];
      for (id in ref) {
        player = ref[id];
        if (player.tokens >= 15) {
          player.winner = true;
          game.over = true;
        }
        if (playerService.players.length === 1) {
          player.winner = true;
          results.push(game.over = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    game.turn.processEndOfTurn = function() {
      var i, len, player, ref;
      if (!game.over) {
        ref = playerService.players;
        for (i = 0, len = ref.length; i < len; i++) {
          player = ref[i];
          playerService.addSafeTurnsToPlayer(player_id, -1);
        }
        return game.buttons.next_turn.disabled = false;
      } else {
        return game.buttons.reset_game.active = true;
      }
    };
    game.turn_fn = function() {
      if (game.over) {
        return game.buttons.next_turn.disabled = true;
      } else {
        game.buttons.next_turn.disabled = true;
        game.turn_number += 1;
        game.turn.rotateCardStacks();
        game.turn.playAIHands();
        cardService.cardsInPlay.show = true;
        game.turn.waitForPlayer = function() {
          if (cardService.numberOfCardsInPlay() === playerService.numberOfPlayers) {
            game.phase = 1;
            console.log("Correct number of player cards found!");
            game.turn.processCardActions();
            game.turn.checkForElimination();
            game.turn.checkForEndOfGame();
            return game.turn.processEndOfTurn();
          } else {
            game.phase = 2;
            console.log("Waiting for player input");
            console.log(cardService.numberOfCardsInPlay(), playerService.numberOfPlayers, cardService.numberOfCardsInPlay() === playerService.numberOfPlayers);
            return $timeout(game.turn.waitForPlayer, 1000);
          }
        };
        return game.turn.waitForPlayer();
      }
    };
    game.userCardClick = function(player_id, card_index, pile, action) {
      var cardPlayed;
      console.log("Game Phase: " + game.phase);
      if (action === 'play_card' && game.phase === 2) {
        cardPlayed = playerService.moveCardToPile(player_id, pile, "in_play", card_index);
        cardService.cardsInPlay.cardsPlayed[player_id] = cardPlayed;
        cardService.cardsInPlay.cardNumberCounts[cardPlayed.id] += 1;
        return cardService.updateCardsInPlay(cardService.cardsInPlay);
      }
    };
    game.buttons = {};
    $http.get('/static/data/buttons.json').success(function(data) {
      return game.buttons = data;
    });
    game.button_actions = {
      "new_game": game.newGame,
      "start_game": game.runGame,
      "next_turn": game.turn_fn,
      "reset_game": game.reset
    };
    game.reset();
    return game;
  };

  app.controller('GameController', ['$http', '$timeout', 'cardService', 'playerService', GameController]);

  app.directive('playArea', [
    'cardService', function(cardService) {
      return {
        restrict: 'E',
        templateUrl: 'partials/play-area',
        link: function(scope, el, attrs) {
          return scope.cardService = cardService;
        }
      };
    }
  ]);

  app.directive('gameHeader', function() {
    return {
      restrict: 'E',
      templateUrl: 'partials/game-header',
      scope: true
    };
  });

  app.directive('gameControlButtons', function() {
    return {
      restrict: 'E',
      templateUrl: 'partials/game-control-buttons',
      scope: true
    };
  });

  return app;

}).call(this);

(function() {
  var app,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  app = angular.module('battlecruisers-cards', []);

  app.service('cardService', [
    '$http', 'playerService', function($http, playerService) {
      var cardService;
      cardService = {};
      cardService.deck = {};
      cardService.getDeck = function() {
        return $http.get('/static/data/cards.json');
      };
      cardService.actions = {
        "3": {
          "main": function(player_id) {
            console.debug("Player " + player_id + " is safe from main effects for this turn and next");
            return playerService.addSafeTurnsToPlayer(player_id, 2);
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " in conflict but nothing happens");
            return null;
          }
        },
        "11": {
          "main": function(player_id) {
            console.debug("Player " + player_id + " earns 4 tokens and discards a card");
            playerService.addTokensToPlayerPile(player_id, 4);
            return playerService.moveCardToPile(player_id, ["hand", "recovery_zone"], "discard_pile");
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict and discards a card");
            return playerService.moveCardToPile(player_id, ["hand", "recovery_zone"], "discard_pile");
          }
        },
        "13": {
          "main": function(player_id) {
            console.debug("Player " + player_id + " earns 3 tokens");
            return playerService.addTokensToPlayerPile(player_id, 3);
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict, so gains 3 tokens but loses 1 for each conflict");
            playerService.addTokensToPlayerPile(player_id, 3);
            return playerService.addTokensToPlayerPile(player_id, -cardService.cardsInPlay.cardNumberCounts["13"]);
          }
        },
        "22": {
          "main": function(player_id) {
            var players, results, victim, victim_id;
            console.debug("Player " + player_id + " takes a token from all players, if they are not in the lead");
            console.log(playerService.whoHasMostTokens());
            console.log(indexOf.call(playerService.whoHasMostTokens(), player_id) < 0);
            players = playerService.players;
            if (indexOf.call(playerService.whoHasMostTokens(), player_id) < 0) {
              results = [];
              for (victim_id in players) {
                victim = players[victim_id];
                if (victim_id !== player_id && victim["safe_turns"] <= 0) {
                  if (victim["tokens"] > 0) {
                    playerService.addTokensToPlayerPile(victim_id, -1);
                    results.push(playerService.addTokensToPlayerPile(player_id, 1));
                  } else {
                    results.push(void 0);
                  }
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict but nothing happens");
            return null;
          }
        },
        "31": {
          "main": function(player_id) {
            var players, results, victim, victim_id;
            console.debug("Player " + player_id + " commands every opponent to discard a card");
            players = playerService.players;
            results = [];
            for (victim_id in players) {
              victim = players[victim_id];
              if (victim_id === !player_id && victim["safe_turns"] <= 0) {
                results.push(playerService.moveCardToPile(victim_id, "discard_pile", "hand"));
              } else {
                results.push(void 0);
              }
            }
            return results;
          },
          "conflict": function(player_id) {
            console.debug("Player " + player_id + " is in conflict and discards a card");
            return playerService.moveCardToPile(player_id, "discard_pile", "hand");
          }
        },
        "43": {
          "main": function(player_id) {
            var players;
            playerService.addTokensToPlayerPile(player_id, 1);
            console.debug("Player " + player_id + " takes 3 cards from their discard pile if they only have one card remaining");
            players = playerService.players;
            if (players[player_id].cards.hand.length === 1) {
              return playerService.moveCardToPile(player_id, "discard_pile", "hand");
            }
          },
          "conflict": function(player_id) {
            var i, index, players, ref, results;
            console.debug("Player " + player_id + " is in conflict and must discard this card (#43)");
            players = playerService.players;
            results = [];
            for (index = i = ref = players[player_id].cards.in_play.length - 1; ref <= 0 ? i < 0 : i > 0; index = ref <= 0 ? ++i : --i) {
              if (players[player_id].cards.in_play[index].id === "43") {
                playerService.moveCardToPile(player_id, "in_play", "discard_pile", index);
                break;
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        }
      };
      cardService.updateDeck = function(deck) {
        cardService.deck = deck;
        return deck;
      };
      cardService.handChoice = [3, 11, 13, 22, 31, 43];
      cardService.getHand = function(card_numbers) {
        var card, card_number, hand, i, len;
        if (card_numbers == null) {
          card_numbers = cardService.handChoice;
        }
        hand = [];
        for (i = 0, len = card_numbers.length; i < len; i++) {
          card_number = card_numbers[i];
          card = cardService.deck[card_number];
          card["id"] = card_number;
          hand.push(card);
        }
        return {
          hand: hand,
          in_play: [],
          discard_pile: [],
          recovery_zone: [],
          active_cards: function(piles) {
            var card_count, j, len1, pile;
            if (piles == null) {
              piles = ["hand", "in_play", "recovery_zone"];
            }
            card_count = 0;
            for (j = 0, len1 = piles.length; j < len1; j++) {
              pile = piles[j];
              card_count += this[pile].length;
            }
            return card_count;
          },
          random_card: function(piles) {
            var j, len1, pile, pile_size, rand;
            if (piles == null) {
              piles = ["hand", "in_play", "recovery_zone"];
            }
            rand = Math.floor(Math.random() * this.active_cards(piles));
            for (j = 0, len1 = piles.length; j < len1; j++) {
              pile = piles[j];
              pile_size = this[pile].length;
              if (rand < pile_size) {
                return {
                  card: this[pile][rand],
                  pile: pile,
                  index: rand
                };
              } else {
                rand -= pile_size;
              }
            }
          }
        };
      };
      cardService.updateCardsInPlay = function(cardsInPlay) {
        return cardService.cardsInPlay = cardsInPlay;
      };
      cardService.numberOfCardsInPlay = function() {
        var card_number, cards_played, count, ref;
        cards_played = 0;
        ref = cardService.cardsInPlay.cardNumberCounts;
        for (card_number in ref) {
          count = ref[card_number];
          cards_played += count;
        }
        return cards_played;
      };
      cardService.resetCardsInPlay = function() {
        return cardService.cardsInPlay = {
          "show": false,
          "cardsPlayed": {},
          "cardNumberCounts": new function() {
            var f, i, len, ref;
            ref = cardService.handChoice;
            for (i = 0, len = ref.length; i < len; i++) {
              f = ref[i];
              this[f] = 0;
            }
            return this;
          }
        };
      };
      return cardService;
    }
  ]);

  app.directive('singleCard', function() {
    return {
      restrict: 'E',
      templateUrl: 'partials/single-card',
      scope: true
    };
  });

  return app;

}).call(this);

(function() {
  var app;

  app = angular.module('battlecruisers-players', []);

  app.directive('playerInfo', [
    'playerService', function(playerService) {
      return {
        restrict: 'E',
        templateUrl: 'partials/player-info',
        link: function(scope, el, attrs) {
          return scope.playerService = playerService;
        }
      };
    }
  ]);

  app.service('playerService', [
    function() {
      var playerService;
      playerService = {};
      playerService.players = {};
      playerService.numberOfPlayers = 0;
      playerService.token_pool = 34;
      playerService.createNewPlayer = function(id, type) {
        var player;
        player = {};
        player.id = id;
        player.tokens = 0;
        player.safe_turns = 0;
        player.status = "NORMAL";
        player.view = 'remote';
        if (type === "ai") {
          player.type = 0;
          player.difficulty = 0;
        } else if (type === "human") {
          player.type = 1;
        }
        playerService.updatePlayer(id, player);
        playerService.numberOfPlayers += 1;
        return player;
      };
      playerService.updatePlayer = function(id, player) {
        playerService.players[id] = player;
        return player;
      };
      playerService.reset = function() {
        playerService.players = {};
        return playerService.token_pool = 34;
      };
      playerService.whoHasMostTokens = function() {
        var highest_tokens, id, player, player_ids, ref;
        highest_tokens = 0;
        player_ids = [];
        ref = playerService.players;
        for (id in ref) {
          player = ref[id];
          if (player.tokens > highest_tokens) {
            highest_tokens = player.tokens;
            player_ids = [id];
          } else if (player.tokens === highest_tokens) {
            player_ids.push(id);
          }
        }
        return player_ids;
      };
      playerService.addSafeTurnsToPlayer = function(player_id, num) {
        var player;
        player = playerService.players[player_id];
        if (player.safe_turns + num > 0) {
          if (num > player.safe_turns) {
            player.safe_turns = num;
          }
        } else {
          player.safe_turns = 0;
        }
        return {
          player_id: player
        };
      };
      playerService.addTokensToPlayerPile = function(player_id, num) {
        var player;
        player = playerService.players[player_id];
        console.log(player);
        if (player.tokens + num > 0) {
          if (playerService.token_pool + num > 0) {
            player.tokens += num;
            playerService.token_pool -= num;
          } else {
            player.tokens += playerService.token_pool;
            playerService.token_pool = 0;
          }
        } else {
          playerService.token_pool -= player.tokens;
          player.tokens = 0;
        }
        return {
          player_id: playerService.players[player_id]
        };
      };
      playerService.randomCardFromHand = function(pile) {
        return Math.floor(Math.random() * pile.length);
      };
      playerService.moveCardToPile = function(player_id, from_pile, to_pile, card) {
        var player;
        if (typeof from_pile !== "string") {
          from_pile = from_pile[Math.floor(Math.random() * from_pile.length)];
        }
        if (card === void 0) {
          card = playerService.players[player_id].cards.random_card([from_pile]).index;
        }
        console.debug("Player " + player_id + " moves Card #" + card + " from " + from_pile + " to " + to_pile);
        player = playerService.players[player_id];
        if (player.cards[from_pile][card] !== void 0) {
          player.cards[to_pile].push(player.cards[from_pile][card]);
        } else {
          throw new Error("That card (" + card + ") is undefined! From: " + from_pile + " To: " + to_pile + " For Player " + player_id);
        }
        return player.cards[from_pile].splice(card, 1)[0];
      };
      return playerService;
    }
  ]);

}).call(this);
